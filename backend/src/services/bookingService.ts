import { prisma } from '@/utils/prisma'
import { BookingStatus, VehicleType, RouteType, DriverStatus, VehicleStatus } from '@prisma/client'
import { VehicleService } from './vehicleService'
import { VehicleServiceMock } from './vehicleServiceMock'
import { UserServiceMock } from './userServiceMock'
import { BookingServiceMock } from './bookingServiceMock'
import { RouteService } from './routeService'
import { TelegramBotService } from './telegramBot'

export interface CreateBookingData {
  telegramId: bigint
  fromLocation: string
  toLocation: string
  vehicleType: VehicleType
  pickupTime?: string
  notes?: string
  distanceKm?: number
}

export interface BookingDetails {
  id: string
  status: BookingStatus
  fromLocation: string
  toLocation: string
  price: number
  pickupTime?: Date
  notes?: string
  user: {
    name?: string
    phone?: string
  }
  vehicle?: {
    brand: string
    model: string
    licensePlate: string
  }
  driver?: {
    name: string
    phone: string
  }
  createdAt: Date
}

export class BookingService {
  // –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –∑–∞–∫–∞–∑
  static async createBooking(data: CreateBookingData): Promise<BookingDetails> {
    console.log('üîç Creating booking for:', data)

    try {
      // 1. –ù–∞–π—Ç–∏ –∏–ª–∏ —Å–æ–∑–¥–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      let user;
      try {
        user = await prisma.user.findUnique({
          where: { telegram_id: String(data.telegramId) }
        })
      } catch (error) {
        console.warn('‚ö†Ô∏è Database not available for user lookup, using mock')
        user = await UserServiceMock.findByTelegramId(String(data.telegramId))
      }

      if (!user) {
        throw new Error('User not found. Please register first.')
      }

      // 2. –†–∞—Å—Å—á–∏—Ç–∞—Ç—å —Å—Ç–æ–∏–º–æ—Å—Ç—å
      const priceCalculation = await RouteService.calculatePrice({
        from: data.fromLocation,
        to: data.toLocation,
        vehicleType: data.vehicleType,
        distance: data.distanceKm
      })

      // 3. –ù–∞–π—Ç–∏ –ø–æ–¥—Ö–æ–¥—è—â–∏–π –∞–≤—Ç–æ–º–æ–±–∏–ª—å
      let vehicle;
      try {
        vehicle = await VehicleService.findSuitableVehicle(data.vehicleType)
      } catch (error) {
        console.warn('‚ö†Ô∏è Database not available for vehicle lookup, using mock')
        vehicle = await VehicleServiceMock.findSuitableVehicle(data.vehicleType)
      }

      // 4. –°–æ–∑–¥–∞—Ç—å –∑–∞–∫–∞–∑
      let booking;
      try {
        booking = await prisma.booking.create({
          data: {
            user_id: user.id,
            from_location: data.fromLocation,
            to_location: data.toLocation,
            route_type: priceCalculation.routeType as RouteType,
            distance_km: priceCalculation.distance,
            price: priceCalculation.totalPrice,
            total_price: priceCalculation.totalPrice,
            passenger_count: 1,
            status: BookingStatus.PENDING,
            pickup_time: data.pickupTime ? new Date(data.pickupTime) : null,
            notes: data.notes,
            vehicle_id: vehicle?.id,
            driver_id: vehicle?.driver?.id,
            route_id: priceCalculation.routeId
          },
          include: {
            user: true,
            vehicle: true,
            driver: true,
            route: true
          }
        })
      } catch (error) {
        console.warn('‚ö†Ô∏è Database not available for booking creation, using mock')
        booking = await BookingServiceMock.createBooking({
          telegramId: data.telegramId,
          fromLocation: data.fromLocation,
          toLocation: data.toLocation,
          vehicleType: data.vehicleType,
          pickupTime: data.pickupTime,
          notes: data.notes,
          distance: priceCalculation.distance,
          totalPrice: priceCalculation.totalPrice
        })
      }

      // 5. –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∞–≤—Ç–æ–º–æ–±–∏–ª—è –∏ –≤–æ–¥–∏—Ç–µ–ª—è (–µ—Å–ª–∏ –Ω–∞–∑–Ω–∞—á–µ–Ω—ã)
      if (vehicle && vehicle.driver) {
        try {
          await Promise.all([
            VehicleService.updateVehicleStatus(vehicle.id, VehicleStatus.BUSY),
            prisma.driver.update({
              where: { id: vehicle.driver.id },
              data: { status: DriverStatus.BUSY }
            })
          ])
        } catch (error) {
          console.warn('‚ö†Ô∏è Could not update vehicle/driver status (DB unavailable)')
        }
      }

      // 6. –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
      try {
        const telegramBot = TelegramBotService.getInstance()

        // –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç—É
        await telegramBot.sendBookingNotification(Number(data.telegramId), {
          fromLocation: booking.from_location,
          toLocation: booking.to_location,
          vehicleType: data.vehicleType,
          price: booking.price
        })

        // –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–∏—Å–ø–µ—Ç—á–µ—Ä—É (–º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–∑–∂–µ)
        // await telegramBot.sendDispatcherNotification(booking)

      } catch (error) {
        console.error('Failed to send notifications:', error)
        // –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–∫–∞–∑–∞ –∏–∑-–∑–∞ –æ—à–∏–±–æ–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
      }

      return this.formatBookingDetails(booking)
    } catch (error) {
      console.error('‚ùå Error in createBooking:', error)

      // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–µ—Ç—Å—è —Å–æ–∑–¥–∞—Ç—å –∑–∞–∫–∞–∑ –æ–±—ã—á–Ω—ã–º —Å–ø–æ—Å–æ–±–æ–º, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–ª–Ω–æ—Å—Ç—å—é –º–æ–∫–æ–≤—É—é –≤–µ—Ä—Å–∏—é
      const priceCalculation = await RouteService.calculatePrice({
        from: data.fromLocation,
        to: data.toLocation,
        vehicleType: data.vehicleType,
        distance: data.distanceKm
      })

      const booking = await BookingServiceMock.createBooking({
        telegramId: data.telegramId,
        fromLocation: data.fromLocation,
        toLocation: data.toLocation,
        vehicleType: data.vehicleType,
        pickupTime: data.pickupTime,
        notes: data.notes,
        distance: priceCalculation.distance,
        totalPrice: priceCalculation.totalPrice
      })

      return this.formatBookingDetails(booking)
    }
  }

  // –ü–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑ –ø–æ ID
  static async getBookingById(id: string): Promise<BookingDetails | null> {
    try {
      const booking = await prisma.booking.findUnique({
        where: { id },
        include: {
          user: true,
          vehicle: true,
          driver: true,
          route: true
        }
      })

      return booking ? this.formatBookingDetails(booking) : null
    } catch (error) {
      console.warn('‚ö†Ô∏è Database not available for booking lookup, using mock')
      const booking = await BookingServiceMock.findById(id)
      return booking ? this.formatBookingDetails(booking) : null
    }
  }

  // –ü–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  static async getUserBookings(telegramId: bigint, limit = 10) {
    try {
      const user = await prisma.user.findUnique({
        where: { telegram_id: String(telegramId) }
      })

      if (!user) {
        throw new Error('User not found')
      }

      const bookings = await prisma.booking.findMany({
        where: { user_id: user.id },
        include: {
          user: true,
          vehicle: true,
          driver: true,
          route: true
        },
        orderBy: {
          created_at: 'desc'
        },
        take: limit
      })

      return bookings.map(booking => this.formatBookingDetails(booking))
    } catch (error) {
      console.warn('‚ö†Ô∏è Database not available for user bookings, using mock')
      const bookings = await BookingServiceMock.getUserBookings(String(telegramId))
      return bookings.map(booking => this.formatBookingDetails(booking))
    }
  }

  // –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞
  static async updateBookingStatus(id: string, status: BookingStatus, notes?: string) {
    const booking = await prisma.booking.update({
      where: { id },
      data: {
        status,
        ...(notes && { notes })
      },
      include: {
        user: true,
        vehicle: true,
        driver: true
      }
    })

    // –û—Å–≤–æ–±–æ–¥–∏—Ç—å —Ä–µ—Å—É—Ä—Å—ã –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –∏–ª–∏ –æ—Ç–º–µ–Ω–µ
    if (status === BookingStatus.COMPLETED || status === BookingStatus.CANCELLED) {
      if (booking.vehicle_id && booking.driver_id) {
        await Promise.all([
          VehicleService.updateVehicleStatus(booking.vehicle_id!, VehicleStatus.AVAILABLE),
          prisma.driver.update({
            where: { id: booking.driver_id! },
            data: { status: DriverStatus.AVAILABLE }
          })
        ])
      }
    }

    // –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Å–º–µ–Ω–µ —Å—Ç–∞—Ç—É—Å–∞
    try {
      const telegramBot = TelegramBotService.getInstance()
      await telegramBot.sendStatusUpdateNotification(
        Number(booking.user.telegram_id),
        booking,
        status
      )
    } catch (error) {
      console.error('Failed to send status update notification:', error)
    }

    return this.formatBookingDetails(booking)
  }

  // –ù–∞–∑–Ω–∞—á–∏—Ç—å –≤–æ–¥–∏—Ç–µ–ª—è –∫ –∑–∞–∫–∞–∑—É
  static async assignDriver(bookingId: string, driverId: string) {
    const driver = await prisma.driver.findUnique({
      where: { id: parseInt(driverId) },
      include: { vehicle: true }
    })

    if (!driver) {
      throw new Error('Driver not found')
    }

    if (driver.status !== DriverStatus.AVAILABLE) {
      throw new Error('Driver is not available')
    }

    const booking = await prisma.booking.update({
      where: { id: bookingId },
      data: {
        driver_id: driver.id,
        vehicle_id: driver.vehicle_id,
        status: BookingStatus.CONFIRMED
      },
      include: {
        user: true,
        vehicle: true,
        driver: true
      }
    })

    // –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –≤–æ–¥–∏—Ç–µ–ª—è –∏ –∞–≤—Ç–æ–º–æ–±–∏–ª—è
    await Promise.all([
      prisma.driver.update({
        where: { id: parseInt(driverId) },
        data: { status: DriverStatus.BUSY }
      }),
      VehicleService.updateVehicleStatus(driver.vehicle_id!, VehicleStatus.BUSY)
    ])

    return this.formatBookingDetails(booking)
  }

  // –ü–æ–ª—É—á–∏—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–∫–∞–∑—ã (–¥–ª—è –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞)
  static async getActiveBookings() {
    const bookings = await prisma.booking.findMany({
      where: {
        status: {
          in: [BookingStatus.PENDING, BookingStatus.CONFIRMED, BookingStatus.IN_PROGRESS]
        }
      },
      include: {
        user: true,
        vehicle: true,
        driver: true,
        route: true
      },
      orderBy: {
        created_at: 'asc'
      }
    })

    return bookings.map(booking => this.formatBookingDetails(booking))
  }

  // –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∑–∞–∫–∞–∑–æ–≤
  static async getBookingStats(period?: 'day' | 'week' | 'month') {
    const now = new Date()
    let startDate: Date

    switch (period) {
      case 'day':
        startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate())
        break
      case 'week':
        startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
        break
      case 'month':
        startDate = new Date(now.getFullYear(), now.getMonth(), 1)
        break
      default:
        startDate = new Date(0) // –í—Å–µ –≤—Ä–µ–º—è
    }

    const [statusStats, totalRevenue, vehicleTypeStats] = await Promise.all([
      // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Å—Ç–∞—Ç—É—Å–∞–º
      prisma.booking.groupBy({
        by: ['status'],
        where: {
          created_at: { gte: startDate }
        },
        _count: {
          status: true
        }
      }),

      // –û–±—â–∞—è –≤—ã—Ä—É—á–∫–∞
      prisma.booking.aggregate({
        where: {
          status: BookingStatus.COMPLETED,
          created_at: { gte: startDate }
        },
        _sum: {
          total_price: true
        }
      }),

      // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Ç–∏–ø–∞–º –∞–≤—Ç–æ–º–æ–±–∏–ª–µ–π
      prisma.booking.groupBy({
        by: ['vehicle_id'],
        where: {
          created_at: { gte: startDate },
          vehicle_id: { not: null }
        },
        _count: {
          vehicle_id: true
        },
        _sum: {
          total_price: true
        }
      })
    ])

    return {
      period,
      statusStats,
      totalRevenue: totalRevenue._sum.total_price || 0,
      vehicleTypeStats
    }
  }

  // –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∑–∞–∫–∞–∑–∞
  private static formatBookingDetails(booking: any): BookingDetails {
    return {
      id: booking.id,
      status: booking.status,
      fromLocation: booking.from_location,
      toLocation: booking.to_location,
      price: Number(booking.price || booking.total_price || 0),
      pickupTime: booking.pickup_time,
      notes: booking.notes,
      user: {
        name: booking.user?.name || booking.user?.first_name,
        phone: booking.user?.phone
      },
      vehicle: booking.vehicle ? {
        brand: booking.vehicle.brand || booking.vehicle.name,
        model: booking.vehicle.model || '',
        licensePlate: booking.vehicle.license_plate || ''
      } : undefined,
      driver: booking.driver ? {
        name: booking.driver.name,
        phone: booking.driver.phone
      } : undefined,
      createdAt: booking.created_at
    }
  }
}
