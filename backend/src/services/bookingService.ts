import { prisma } from '@/utils/prisma'
import { BookingStatus, VehicleType, RouteType, DriverStatus, VehicleStatus } from '@prisma/client'
import { VehicleService } from './vehicleService'
import { RouteService } from './routeService'
import { TelegramBotService } from './telegramBot'

export interface CreateBookingData {
  telegramId: bigint
  fromLocation: string
  toLocation: string
  vehicleType: VehicleType
  pickupTime?: string
  notes?: string
  distanceKm?: number
}

export interface BookingDetails {
  id: string
  status: BookingStatus
  fromLocation: string
  toLocation: string
  price: number
  pickupTime?: Date
  notes?: string
  user: {
    name?: string
    phone?: string
  }
  vehicle?: {
    brand: string
    model: string
    licensePlate: string
  }
  driver?: {
    name: string
    phone: string
  }
  createdAt: Date
}

export class BookingService {
  // –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –∑–∞–∫–∞–∑
  static async createBooking(data: CreateBookingData): Promise<BookingDetails> {
    console.log('üîç Creating booking for:', data)

    try {
      // 1. –ù–∞–π—Ç–∏ –∏–ª–∏ —Å–æ–∑–¥–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      let user = await prisma.user.findUnique({
        where: { telegram_id: String(data.telegramId) }
      })

      if (!user) {
        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
        user = await prisma.user.create({
          data: {
            telegram_id: String(data.telegramId),
            language_code: 'ru'
          }
        })
      }

      // 2. –†–∞—Å—Å—á–∏—Ç–∞—Ç—å —Å—Ç–æ–∏–º–æ—Å—Ç—å
      const priceCalculation = await RouteService.calculatePrice({
        from: data.fromLocation,
        to: data.toLocation,
        vehicleType: data.vehicleType,
        distance: data.distanceKm
      })

      // 3. –ù–∞–π—Ç–∏ –ø–æ–¥—Ö–æ–¥—è—â–∏–π –∞–≤—Ç–æ–º–æ–±–∏–ª—å
      const vehicle = await VehicleService.findSuitableVehicle(data.vehicleType)

      // 4. –°–æ–∑–¥–∞—Ç—å –∑–∞–∫–∞–∑
      const booking = await prisma.booking.create({
        data: {
          user_id: user.id,
          from_location: data.fromLocation,
          to_location: data.toLocation,
          route_type: priceCalculation.routeType as RouteType,
          distance_km: priceCalculation.distance,
          price: priceCalculation.totalPrice,
          total_price: priceCalculation.totalPrice,
          passenger_count: 1,
          status: BookingStatus.PENDING,
          pickup_time: data.pickupTime ? new Date(data.pickupTime) : null,
          notes: data.notes,
          vehicle_id: vehicle?.id,
          driver_id: vehicle?.driver?.id,
          route_id: priceCalculation.routeId
        },
        include: {
          user: true,
          vehicle: true,
          driver: true,
          route: true
        }
      })

      // 5. –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∞–≤—Ç–æ–º–æ–±–∏–ª—è –∏ –≤–æ–¥–∏—Ç–µ–ª—è (–µ—Å–ª–∏ –Ω–∞–∑–Ω–∞—á–µ–Ω—ã)
      if (vehicle && vehicle.driver) {
        await Promise.all([
          VehicleService.updateVehicleStatus(vehicle.id, VehicleStatus.BUSY),
          prisma.driver.update({
            where: { id: vehicle.driver.id },
            data: { status: DriverStatus.BUSY }
          })
        ])
      }

      // 6. –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
      try {
        const telegramBot = TelegramBotService.getInstance()

        // –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç—É
        await telegramBot.sendBookingNotification(Number(data.telegramId), {
          fromLocation: booking.from_location,
          toLocation: booking.to_location,
          vehicleType: data.vehicleType,
          price: booking.price
        })

        // –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–∏—Å–ø–µ—Ç—á–µ—Ä—É
        await telegramBot.sendDispatcherNotification({
          id: booking.id,
          fromLocation: booking.from_location,
          toLocation: booking.to_location,
          vehicleType: data.vehicleType,
          price: booking.price,
          pickupTime: booking.pickup_time,
          notes: booking.notes,
          user: {
            name: booking.user.name || booking.user.first_name,
            phone: booking.user.phone
          }
        })

      } catch (error) {
        console.error('Failed to send notifications:', error)
        // –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–∫–∞–∑–∞ –∏–∑-–∑–∞ –æ—à–∏–±–æ–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
      }

      return this.formatBookingDetails(booking)
    } catch (error) {
      console.error('‚ùå Error in createBooking:', error)
      throw error
    }
  }

  // –ü–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑ –ø–æ ID
  static async getBookingById(id: string): Promise<BookingDetails | null> {
    const booking = await prisma.booking.findUnique({
      where: { id },
      include: {
        user: true,
        vehicle: true,
        driver: true,
        route: true
      }
    })

    return booking ? this.formatBookingDetails(booking) : null
  }

  // –ü–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  static async getUserBookings(telegramId: bigint, limit = 10) {
    const user = await prisma.user.findUnique({
      where: { telegram_id: String(telegramId) }
    })

    if (!user) {
      return []
    }

    const bookings = await prisma.booking.findMany({
      where: { user_id: user.id },
      include: {
        user: true,
        vehicle: true,
        driver: true,
        route: true
      },
      orderBy: {
        created_at: 'desc'
      },
      take: limit
    })

    return bookings.map(booking => this.formatBookingDetails(booking))
  }

  // –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞
  static async updateBookingStatus(id: string, status: BookingStatus, notes?: string) {
    const booking = await prisma.booking.update({
      where: { id },
      data: {
        status,
        ...(notes && { notes })
      },
      include: {
        user: true,
        vehicle: true,
        driver: true
      }
    })

    // –û—Å–≤–æ–±–æ–¥–∏—Ç—å —Ä–µ—Å—É—Ä—Å—ã –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –∏–ª–∏ –æ—Ç–º–µ–Ω–µ
    if (status === BookingStatus.COMPLETED || status === BookingStatus.CANCELLED) {
      if (booking.vehicle_id && booking.driver_id) {
        await Promise.all([
          VehicleService.updateVehicleStatus(booking.vehicle_id!, VehicleStatus.AVAILABLE),
          prisma.driver.update({
            where: { id: booking.driver_id! },
            data: { status: DriverStatus.AVAILABLE }
          })
        ])
      }
    }

    // –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Å–º–µ–Ω–µ —Å—Ç–∞—Ç—É—Å–∞
    try {
      const telegramBot = TelegramBotService.getInstance()
      await telegramBot.sendStatusUpdateNotification(
        Number(booking.user.telegram_id),
        booking,
        status
      )
    } catch (error) {
      console.error('Failed to send status update notification:', error)
    }

    return this.formatBookingDetails(booking)
  }

  // –ù–∞–∑–Ω–∞—á–∏—Ç—å –≤–æ–¥–∏—Ç–µ–ª—è –∫ –∑–∞–∫–∞–∑—É
  static async assignDriver(bookingId: string, driverId: string) {
    const driver = await prisma.driver.findUnique({
      where: { id: parseInt(driverId) },
      include: { vehicle: true }
    })

    if (!driver) {
      throw new Error('Driver not found')
    }

    if (driver.status !== DriverStatus.AVAILABLE) {
      throw new Error('Driver is not available')
    }

    const booking = await prisma.booking.update({
      where: { id: bookingId },
      data: {
        driver_id: driver.id,
        vehicle_id: driver.vehicle_id,
        status: BookingStatus.CONFIRMED
      },
      include: {
        user: true,
        vehicle: true,
        driver: true
      }
    })

    // –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –≤–æ–¥–∏—Ç–µ–ª—è –∏ –∞–≤—Ç–æ–º–æ–±–∏–ª—è
    await Promise.all([
      prisma.driver.update({
        where: { id: parseInt(driverId) },
        data: { status: DriverStatus.BUSY }
      }),
      VehicleService.updateVehicleStatus(driver.vehicle_id!, VehicleStatus.BUSY)
    ])

    // –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç—É –æ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–∏ –≤–æ–¥–∏—Ç–µ–ª—è
    try {
      const telegramBot = TelegramBotService.getInstance()
      await telegramBot.sendDriverAssignmentNotification(
        Number(booking.user.telegram_id),
        {
          fromLocation: booking.from_location,
          toLocation: booking.to_location,
          vehicle: booking.vehicle
        },
        booking.driver
      )
    } catch (error) {
      console.error('Failed to send driver assignment notification:', error)
    }

    return this.formatBookingDetails(booking)
  }

  // –ü–æ–ª—É—á–∏—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–∫–∞–∑—ã (–¥–ª—è –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞)
  static async getActiveBookings() {
    const bookings = await prisma.booking.findMany({
      where: {
        status: {
          in: [BookingStatus.PENDING, BookingStatus.CONFIRMED, BookingStatus.IN_PROGRESS]
        }
      },
      include: {
        user: true,
        vehicle: true,
        driver: true,
        route: true
      },
      orderBy: {
        created_at: 'asc'
      }
    })

    return bookings.map(booking => this.formatBookingDetails(booking))
  }

  // –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∑–∞–∫–∞–∑–æ–≤
  static async getBookingStats(period?: 'day' | 'week' | 'month') {
    const now = new Date()
    let startDate: Date

    switch (period) {
      case 'day':
        startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate())
        break
      case 'week':
        startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
        break
      case 'month':
        startDate = new Date(now.getFullYear(), now.getMonth(), 1)
        break
      default:
        startDate = new Date(0) // –í—Å–µ –≤—Ä–µ–º—è
    }

    const [statusStats, totalRevenue, vehicleTypeStats] = await Promise.all([
      // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Å—Ç–∞—Ç—É—Å–∞–º
      prisma.booking.groupBy({
        by: ['status'],
        where: {
          created_at: { gte: startDate }
        },
        _count: {
          status: true
        }
      }),

      // –û–±—â–∞—è –≤—ã—Ä—É—á–∫–∞
      prisma.booking.aggregate({
        where: {
          status: BookingStatus.COMPLETED,
          created_at: { gte: startDate }
        },
        _sum: {
          total_price: true
        }
      }),

      // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Ç–∏–ø–∞–º –∞–≤—Ç–æ–º–æ–±–∏–ª–µ–π
      prisma.booking.groupBy({
        by: ['vehicle_id'],
        where: {
          created_at: { gte: startDate },
          vehicle_id: { not: null }
        },
        _count: {
          vehicle_id: true
        },
        _sum: {
          total_price: true
        }
      })
    ])

    return {
      period,
      statusStats,
      totalRevenue: totalRevenue._sum.total_price || 0,
      vehicleTypeStats
    }
  }

  // –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∑–∞–∫–∞–∑–∞
  private static formatBookingDetails(booking: any): BookingDetails {
    return {
      id: booking.id,
      status: booking.status,
      fromLocation: booking.from_location,
      toLocation: booking.to_location,
      price: Number(booking.price || booking.total_price || 0),
      pickupTime: booking.pickup_time,
      notes: booking.notes,
      user: {
        name: booking.user?.name || booking.user?.first_name,
        phone: booking.user?.phone
      },
      vehicle: booking.vehicle ? {
        brand: booking.vehicle.brand || booking.vehicle.name,
        model: booking.vehicle.model || '',
        licensePlate: booking.vehicle.license_plate || ''
      } : undefined,
      driver: booking.driver ? {
        name: booking.driver.name,
        phone: booking.driver.phone
      } : undefined,
      createdAt: booking.created_at
    }
  }

  // –ù–∞—á–∞—Ç—å —Ä–µ–π—Å
  static async startTrip(bookingId: string, driverId: number, location?: { lat: number, lng: number }) {
    console.log(`üöÄ –ù–∞—á–∏–Ω–∞–µ–º —Ä–µ–π—Å ${bookingId} –≤–æ–¥–∏—Ç–µ–ª–µ–º ${driverId}`)

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∑–∞–∫–∞–∑ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –∏–º–µ–µ—Ç —Å—Ç–∞—Ç—É—Å CONFIRMED
    const booking = await prisma.booking.findUnique({
      where: { id: bookingId },
      include: {
        user: true,
        driver: true,
        vehicle: true
      }
    })

    if (!booking) {
      throw new Error('Booking not found')
    }

    if (booking.status !== BookingStatus.CONFIRMED && booking.status !== BookingStatus.PENDING) {
      throw new Error('Booking must be PENDING or CONFIRMED to start trip')
    }

    if (booking.driver_id !== driverId) {
      throw new Error('Driver is not assigned to this booking')
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞
    const updatedBooking = await prisma.booking.update({
      where: { id: bookingId },
      data: {
        status: BookingStatus.IN_PROGRESS,
        updated_at: new Date()
      },
      include: {
        user: true,
        driver: true,
        vehicle: true
      }
    })

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –≤–æ–¥–∏—Ç–µ–ª—è
    await prisma.driver.update({
      where: { id: driverId },
      data: { status: DriverStatus.BUSY }
    })

    console.log(`‚úÖ –†–µ–π—Å ${bookingId} –Ω–∞—á–∞—Ç`)

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç—É
    try {
      if (booking.user.telegram_id) {
        const telegramBot = TelegramBotService.getInstance()
        await telegramBot.sendMessage(
          Number(booking.user.telegram_id),
          `üöó –í–∞—à —Ä–µ–π—Å –Ω–∞—á–∞—Ç!\n\n` +
          `üìç –ú–∞—Ä—à—Ä—É—Ç: ${booking.from_location} ‚Üí ${booking.to_location}\n` +
          `üë§ –í–æ–¥–∏—Ç–µ–ª—å: ${booking.driver?.name}\n` +
          `üìû –¢–µ–ª–µ—Ñ–æ–Ω: ${booking.driver?.phone}\n` +
          `üöô –ê–≤—Ç–æ–º–æ–±–∏–ª—å: ${booking.vehicle?.brand} ${booking.vehicle?.model}\n` +
          `üî¢ –ì–æ—Å–Ω–æ–º–µ—Ä: ${booking.vehicle?.license_plate}\n\n` +
          `–ü—Ä–∏—è—Ç–Ω–æ–π –ø–æ–µ–∑–¥–∫–∏! üõ£Ô∏è`
        )
      }
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –Ω–∞—á–∞–ª–µ —Ä–µ–π—Å–∞:', error)
    }

    return updatedBooking
  }

  // –ó–∞–≤–µ—Ä—à–∏—Ç—å —Ä–µ–π—Å
  static async completeTrip(bookingId: string, driverId: number, location?: { lat: number, lng: number }) {
    console.log(`‚úÖ –ó–∞–≤–µ—Ä—à–∞–µ–º —Ä–µ–π—Å ${bookingId} –≤–æ–¥–∏—Ç–µ–ª–µ–º ${driverId}`)

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∑–∞–∫–∞–∑ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –∏–º–µ–µ—Ç —Å—Ç–∞—Ç—É—Å IN_PROGRESS
    const booking = await prisma.booking.findUnique({
      where: { id: bookingId },
      include: {
        user: true,
        driver: true,
        vehicle: true
      }
    })

    if (!booking) {
      throw new Error('Booking not found')
    }

    if (booking.status !== BookingStatus.IN_PROGRESS) {
      throw new Error('Booking is not in progress')
    }

    if (booking.driver_id !== driverId) {
      throw new Error('Driver is not assigned to this booking')
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–∞
    const updatedBooking = await prisma.booking.update({
      where: { id: bookingId },
      data: {
        status: BookingStatus.COMPLETED,
        updated_at: new Date()
      },
      include: {
        user: true,
        driver: true,
        vehicle: true
      }
    })

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –≤–æ–¥–∏—Ç–µ–ª—è
    await prisma.driver.update({
      where: { id: driverId },
      data: { status: DriverStatus.AVAILABLE }
    })

    console.log(`‚úÖ –†–µ–π—Å ${bookingId} –∑–∞–≤–µ—Ä—à–µ–Ω`)

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç—É
    try {
      if (booking.user.telegram_id) {
        const telegramBot = TelegramBotService.getInstance()
        await telegramBot.sendMessage(
          Number(booking.user.telegram_id),
          `‚úÖ –í–∞—à —Ä–µ–π—Å –∑–∞–≤–µ—Ä—à–µ–Ω!\n\n` +
          `üìç –ú–∞—Ä—à—Ä—É—Ç: ${booking.from_location} ‚Üí ${booking.to_location}\n` +
          `üí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å: ${booking.price} —Å—É–º\n` +
          `üë§ –í–æ–¥–∏—Ç–µ–ª—å: ${booking.driver?.name}\n\n` +
          `–°–ø–∞—Å–∏–±–æ –∑–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –Ω–∞—à–µ–≥–æ —Å–µ—Ä–≤–∏—Å–∞! üôè\n` +
          `–û—Ü–µ–Ω–∏—Ç–µ –ø–æ–µ–∑–¥–∫—É –∏ –æ—Å—Ç–∞–≤—å—Ç–µ –æ—Ç–∑—ã–≤.`
        )
      }
    } catch (error) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ä–µ–π—Å–∞:', error)
    }

    return updatedBooking
  }
}
